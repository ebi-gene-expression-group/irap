#!/usr/bin/env Rscript
#; -*- mode: R;-*-
# =========================================================
# Copyright 2012-2018,  Nuno A. Fonseca (nuno dot fonseca at gmail dot com)
#
# This file is part of iRAP.
#
# This is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with iRAP.  If not, see <http://www.gnu.org/licenses/>.
#
# =========================================================

################################################################################
# Initialisation
################################################################################
suppressPackageStartupMessages(library("optparse"))

IRAP.DIR <- Sys.getenv(c("IRAP_DIR"))
if ( IRAP.DIR == "" ) {
  cat("ERROR: environment variable IRAP_DIR is not set\n")
  q(status=1)
}

# specify our desired options in a list

source(paste(IRAP.DIR,"aux/R","irap_utils.R",sep="/"))
pdebug.enabled <- TRUE

################################################################################
# Argument parsing
################################################################################

usage <- "irap_sdrf2conf --name exp_name --species species --sdrf file --out_conf  [options]"
filenames <- c("sdrf_file","idf_file")

option_list <- list(
  make_option(c("-n", "--name"), type="character", dest="name", default=NULL, help="(short) name of the experiment (no spaces)"),
  make_option(c("--species"), type="character", dest="species", default=NULL, help="Species name."),
  make_option(c("--species_conf"), type="character", dest="species_conf", default=NULL, help="iRAP species config file."),
  make_option(c("--data_dir"), type="character", dest="data_dir", default=".", help="iRAP's toplevel data directory"),
  make_option(c("--raw_dir"), type="character", dest="raw_dir", default=".", help="fastq directory"),
  make_option(c("--sop"), type="character", dest="sop", default=NULL, help="iRAP's toplevel data directory"),
  make_option(c("--nc"), type="numeric", dest="nc", default=0, help="estimated number of clusters [default %default]"),
  make_option(c("--nc_window"), type="numeric", dest="nc_window", default=10, help="Clusters window [default %default]"),  
  make_option(c("-s", "--sdrf"), type="character", dest="sdrf_file", default=NULL, help="SDRF file name"),
  make_option(c("-i", "--idf"), type="character", dest="idf_file", default=NULL, help="IDF file name"),
  make_option(c("--sc"), action="store_true",default=FALSE,dest="is_sc",help="Single cell experiment?. Default is FALSE."),
  make_option(c("-c","--check_only"),action="store_true",dest="check_only",default=FALSE,help="Checks the sdrf/idf but skips the generation of the configuration file."),
  make_option(c("-v","--verbose"),action="store_true",dest="verbose",default=FALSE,help="Produce verbose output."),
  make_option(c("--atlas"),action="store_true",dest="atlas_mode",default=FALSE,help="Enable more stringent checks for the sdrf/idf files (for ExpressionAtlas)"),
  make_option(c("--debug"),action="store_true",dest="debug",default=FALSE,help="Debug mode"),
  make_option(c("--subfolders"),action="store_true",dest="fastq.splited.by.subfolders",default=FALSE,help="Are the files distributed across subfolders"),
  make_option(c("-o", "--out_conf"), type="character",default=NULL,help="Filename of the new iRAP's configuration file.")
)

multiple.options = list()
mandatory <- c("sdrf_file","out_conf","name","species", "species_conf", "idf_file")

opt <- myParseArgs(usage = usage, option_list=option_list,filenames.exist=filenames,multiple.options=list(),mandatory=mandatory)

pdebug.enabled <- opt$debug

################################################################################
# Function definitions
################################################################################

# Record warnings as we run checks

warnings.lst <- c()
addWarning <- function(...) {
  warnings.lst <- append(warnings.lst,paste0(...))
  assign("warnings.lst",warnings.lst,envir = .GlobalEnv)
}

printAllWarnings <- function() {
  n <- length(warnings.lst)
  if ( n > 0 ) return
  pinfo(n," warnings. Unique entries:")
  prints <- sapply(unique(warnings.lst),pwarning)
}

# Print info only in the verbose case

print.info <- function(...){
  if (opt$verbose){
    pinfo(paste(...))
  }
}

# Simplify column names

normalize.cols <- function(vals,strip.brackets=TRUE) {
  ## try to workaround typos & inconsistencies
  x <- vals
  if (strip.brackets)
    x <- gsub("\\].*","",gsub(".*\\[","",x))
  else {
    x <- gsub(" +\\]","]",gsub(" +\\[","[",x))
    x <- gsub("] +","]",x)
  }
  # a space or underscore seems to be the same thing
  x <- gsub("_+"," ",x) ## no underscores
  return(tolower(gsub(" +"," ",x))) ##lowercase and single space
}

# Check for SDRF column presence

colsInSDRF <- function(cols, sdrf, comment.cols=FALSE,  characteristic.cols=FALSE, factor.cols=FALSE, exit.on.error = FALSE) {
  
  if ( length(cols) == 0 ) return()
  
  sdrf.cols <- normalize.cols(colnames(sdrf),strip.brackets=FALSE)
  to.check.cols <- normalize.cols(cols,strip.brackets=FALSE)
  if (comment.cols) {
    to.check.cols <- paste("comment[",to.check.cols,"]",sep="")
  }
  if (factor.cols) {
    to.check.cols <- paste("factorvalue[",to.check.cols,"]",sep="")
  }
  if (characteristic.cols) {
    to.check.cols <- paste("characteristics[",to.check.cols,"]",sep="")
  }
  if ( !comment.cols && ! characteristic.cols && !factor.cols ) {        
    sdrf.cols <- normalize.cols(colnames(sdrf),strip.brackets=TRUE)
    to.check.cols <- normalize.cols(cols,strip.brackets=TRUE)
  }
  found <- to.check.cols %in% sdrf.cols
  
  if (any(! found) ) {
    missed_cols <- cols[! found]
    missing.error <- paste0("SDRF: Column(s) ", paste(missed_cols, collapse=","), " not found")
    
    if (exit.on.error) {
      perror(missing.error)
      q(status=1)
    }
    addWarning(missing.error)
  }
  return(found)
}

# Get an SDRF column, normalising the supplied field name

getSDRFCol <- function(cols, sdrf, order.by = NULL, drop = TRUE){
  sdrf.cols <- normalize.cols(colnames(sdrf),strip.brackets=FALSE)
  to.check.cols <- normalize.cols(cols,strip.brackets=FALSE)
  
  result <- sdrf[,to.check.cols[to.check.cols %in% sdrf.cols], drop = FALSE]
  
  if ( ! is.null(order.by)){
    result <- result[order(result[,normalize.cols(colnames(result)) == normalize.cols(order.by)]),, drop = FALSE]
  }
  
  if (drop && ncol(result) == 1){
    result[,1]
  }else{
    result
  }
}

# Set an SDRF column, normalising the supplied field name

setSDRFCol <- function(cols, sdrf, vals){
  sdrf.cols <- normalize.cols(colnames(sdrf),strip.brackets=FALSE)
  to.check.cols <- normalize.cols(cols,strip.brackets=FALSE)
  
  sdrf[,to.check.cols[to.check.cols %in% sdrf.cols]] <- vals
  sdrf
}

# Check that a value is filled

populated <- function(y){
  unlist(lapply(y, function(x){
    x != '' & x != -1 & gsub(' ', '', x) != '' & ! is.na(x)
  }))
}

# Check files exist

fastqFileExists <- function(filenames, topdir, subfolders = F){
  
  addLibSubfolder <- function(f) {
    paste0(system(paste0("get_lib_folder ",f),intern=TRUE),"/",f)
  }
  
  fixFilename <- function(f) {
    paste0(dirname(f),"/",gsub("#","_",basename(f)))
  }
  
  if (subfolders) {
    filenames <- sapply(filenames,addLibSubfolder)
  }
  
  file.exists(sapply(file.path(topdir, filenames), fixFilename))
}

# Check if a method is a droplet protocol

is.droplet.protocol <- function(x){
  is.singlecell && tolower(x) %in% tolower(sc.droplet.protocols)
}

# Get the contents of a .info file for a run, if available

getRunInfo <- function(run, layout){
  runfiles <- run.fastq.files[[run]]
  info.file <- file.path(opt$data_dir, "raw_data", opt$raw_dir, paste0(runfiles[1], ".info"))
  
  if (file.exists(info.file)){
    
    # Read in the content of the info file
    rr <- readLines(info.file)
    
    # Info file content has variable prefixes derived from file names
    # which are not always the same as the run name. So we need to rename
    # the variables
    
    # Use the _rs field to determine the file prefix, and use that to rename the other variables
    
    info.prefix = sub('(.*)_rs.*', '\\1', grep('_rs=', rr, value = TRUE))
    rr <- sub(info.prefix, run, rr)
    
    # Read from the info files. Note/warning: there is an assumption that
    # the lib name (file basename prefix)  corresponds to the run name.
    # The code needs to be changed if that is not the case.
    
    rr <- system(paste0("cat ",info.file,"|sed -E 's/_L[0-9]+_R[A0-9]+_[0-9]+//'"),intern=TRUE)
    
    strand <- getSDRFCol('library strand', layout, drop = FALSE)[run,]
    
    if ( grepl("(first|second)",strand ) ) {
      
      # If SDRF has a strand definition for this run, discard the one from the info file
      
      rr <- rr[grep('strand', rr, invert = TRUE)]
      if ( grepl("first",strand ) ){
        rr <- c(rr ,paste0("",run,"_strand=first"))
      } else {
        rr <- c(rr,paste0("",run,"_strand=second"))
      }
    }
    
    # Add in index
    
    if ( "index1 file" %in% names(runfiles)){
      rr <- c(rr, paste0("",run,"_index1=", runfiles[['index1 file']]))
    } 
    if ( "index2 file" %in% names(runfiles)){
      rr <- c(rr, paste0("",run,"_index2=", runfiles[['index2 file']]))
    } 
    
    # Record a technical replicate group
    if ( colsInSDRF(techrep.col, layout) ){
      techrep.groups <- getSDRFCol(techrep.col, layout, drop = FALSE)
      tr.numeric.groups <- as.numeric(as.factor(techrep.groups[,1]))
      
      rr <- c(rr,paste0("",run,"_sample=", tr.numeric.groups[rownames(techrep.groups) == run]))
    }
    rr
  }else{
    addWarning(paste("Info file", info.file, 'not found'))  
  }
}

################################################################################
# Basic initalisation 
################################################################################

cat("\n")
pinfo(">>> Commencing SDRF validation")

# Do some introspection on arguments

print.info("### Argument values")

for ( n in names(opt) ) {
  print.info(paste0(n,"=",opt[[n]]))
}

# Set some variable names we'll be using a lot

techrep.col <- 'technical replicate group'
sc.identifier.col <- 'single cell identifier'
sc.protocol.col <- 'library construction'
is.singlecell <- FALSE

################################################################################
# First round SDRF field checks: before we know about field content 
################################################################################

# Load the SDRF

print.info("Loading SDRF ",opt$sdrf_file," ...")
sdrf <- read.tsv(opt$sdrf_file,header=TRUE,comment.char="",fill=TRUE)
print.info("Loading SDRF...done.")

# Do we have enough rows that we'll have to split the files? 

split.files.by.subfolders <- FALSE
if ( nrow(sdrf) > 5090 || opt$fastq.splited.by.subfolders) {    
  split.files.by.subfolders <- TRUE
}

## Factors should not be simultaneously comments, niether should characteristics 

factors <- normalize.cols(colnames(sdrf)[grepl("^factor ?value",colnames(sdrf),ignore.case=TRUE)])
comments <- normalize.cols(colnames(sdrf)[grepl("^comment",colnames(sdrf),ignore.case=TRUE)])
characteristics <- normalize.cols(colnames(sdrf)[grepl("^characteristics",colnames(sdrf),ignore.case=TRUE)])

compare <- list( factors = factors, characteristics = characteristics  )
for (comp in names(compare)){
  common <- intersect( compare[[comp]], comments )
  if (length(common)>0) {
    err_msg <- paste0("SDRF: common ", comp," and comments - ",paste(common,collapse=","))
    if ( opt$atlas_mode==TRUE ) {
      perror(err_msg)
      q(status=1)
    }
    addWarning(err_msg)
  }
}

## Verify presence of mandatory columns (SDRF) and regularise names

expected.cols <- c("Source Name")
expected.comment.cols <- c("LIBRARY_STRATEGY","LIBRARY_SOURCE","LIBRARY_SELECTION","LIBRARY_LAYOUT","FASTQ_URI")
expected.characteristic.cols <- c()
expected.factor.cols <- c()
opt.cols <- c("ORGANISM","organism part","sex","spike in","molecule","technical replicate group","ENA_RUN","ENA_SAMPLE","Scan Name")
layout.cols <- c("run", "library_layout", "ena_sample", "library_layout", "library_strand", "technical replicate group")

################################################################################
# Load and check the IDF where provided, and cross-reference with the SDRF
################################################################################

idf <- NULL
idf.attrs <- idf.factors <- c()

if ( !is.null(opt$idf_file) ) {
  print.info("Loading IDF...")
  idf <- read.tsv(opt$idf_file,header=FALSE,comment.char="",fill=TRUE,quote="")
  if (is.null(idf) ) {
    perror("Error while loading IDF file ",opt$idf_file)
    q(status=1)
  }
  print.info("Loading IDF...done.")
  
  ## exclude blank lines
  
  idf <- idf[idf$V1!="",,drop=FALSE]
  
  ## SecondaryAccession and SequenceDataURI may be non-unique
  
  allowed_dups <- c('comment[sequencedatauri]', 'comment[secondaryaccession]')
  
  for (ad in allowed_dups){
    if ( sum(tolower(idf[,1]) == ad) > 1 ) {
      addWarning("IDF: Multiple '", ad,"' entries")
    }
  }
  
  idf <- subset(idf, ! tolower(V1) %in% allowed_dups)
  
  ## basic idf check (non unique rownames). Some duplicate fields allowed.
  
  dups <- unique(idf[duplicated(idf[,1]), 1])
  
  if ( length(dups) > 0 ) {
    dupss <- paste(dups, sep=",", collapse=",")
    perror("Duplicated entries: ", dupss)
    q(status=1)
  }
  
  ## error handling should be improved...
  rownames(idf) <- tolower(gsub("\\s*\\]\\s*","",gsub("^\\s*COMMENT\\s*\\[\\s*","",as.character(idf[,1]),ignore.case=TRUE)))
  idf <- idf[,-1,drop=FALSE]
  
  ## be tolerant about the EA comments
  rownames(idf) <- gsub("^ea","",rownames(idf))
  
  ## initial check
  if (! "sdrf file" %in% rownames(idf) ) {
    perror("SDRF file missing from IDF file")
    q(status=1)
  }
  
  if ( idf["sdrf file",1]!=basename(opt$sdrf_file) ) {      
    perror("SDRF file in IDF (",idf["sdrf file",1],") differs from given sdrf file name ",basename(opt$sdrf_file))
    q(status=1)
  }
  
  ##expectedclusters
  ##
  ## ExperimentType       differential|baseline (mandatory)
  ## ExpectedClusters     may be empty
  ## AdditionalAttributes - characteristics (optional) exist in the SDRF
  ## AEExperimentType RNA-seq of coding RNA from single cells (single cell)
  ## Protocol Name should match SDRF
  ## Experimental Factor Name (mandatory) exist in the SDRF
  ## note: factors and characteristics should always be lower case!! @Laura
  
  expected.in.idf <- c()
  
  # Required fields for single-cell
  
  if ( is.singlecell ) {
    expected.in.idf <- c("expectedclusters")
    names(expected.in.idf) <- c("EAExpectedClusters")
  }
  
  # Required fields for Atlas
  
  if ( opt$atlas_mode ) {
    expected.in.idf2 <- c("experimenttype","experimental factor name","protocol name")
    names(expected.in.idf2) <- c("AEExperimentType","Experimental Factor Name","Protocol Name")
    expected.in.idf <- c(expected.in.idf,expected.in.idf2)
  }
  
  # Error where required IDF fields not present
  
  not.present <- (!expected.in.idf %in% rownames(idf))
  if ( sum(not.present)>0 ) {
    perror("IDF incomplete. Missing ",paste(names(expected.in.idf)[not.present],sep=",",collapse=","))
    q(status=1)
  }
  
  # Additional IDF checks for Atlas
  
  if ( opt$atlas_mode ) {
    
    if ( ! tolower(idf["experimenttype",1]) %in% c("baseline","differential") ){
      perror("IDF error in EAExperimentType: Invalid value (",idf["experimenttype",1],") expected baseline or differential")
      q(status=1)
    }
    
    ## Check the experiment type
    
    exp.type <- tolower(idf["aeexperimenttype",1])
    valid.exp.types = c( single_cell = "RNA-seq of coding RNA from single cells", bulk = "RNA-seq of coding RNA" )
    
    if ( ! exp.type %in% tolower(valid.exp.types) ){
      perror("IDF error in AEExperimentType: Invalid value (", exp.type,") expected ",paste(valid.exp.types, sep=" or ", collapse=" or "))
      q(status=1)
    }
    
    # Override argument if we find single-cell experiment type
    
    is.singlecell <- names(valid.exp.types)[tolower(valid.exp.types) == exp.type] == 'single_cell'
    
    ## - Experimental Factor Name (mandatory) exist in the SDRF
    
    idf.factors <- idf["experimental factor name",][idf["experimental factor name",] != '']
    
    ## all factors should be in lower case
    if ( any(idf.factors != tolower(idf.factors)) ) {
      perror("IDF error in  Experimental Factor Name: values should be in lower case")
      q(status)
    }
    
    ## and match the sdrf. Ignore single cell identifier when validating against SDRF- it's not a real factor 
    
    if (any(sort(setdiff(idf.factors, sc.identifier.col)) != sort(setdiff(factors, sc.identifier.col)))){
      perror("SDRF/IDF inconsistency: factor values do not match")
      q(status=1)
    }
  }
  
  # Check the ExpectedClusters specification
  
  if ( idf["expectedclusters",1] != "" ) {
    x <- as.numeric(idf["expectedclusters",1])
    if (is.na(x) || x < 1 ) {
      perror("IDF error in AEExpectedClusters: Invalid value  (",idf["expectedclusters",1],")")
      q(status=1)
    }
    opt$nc <- x
  }
  
  # AdditionalAttributes - characteristics (optional) exist in the SDRF
  
  if ( "additionalattributes" %in% rownames(idf) && idf["additionalattributes",1] != "" ) {
    idf.attrs <- idf["additionalattributes",]
    
    # exclude "" and ignore case
    idf.attrs <- sapply(idf.attrs[idf.attrs!=""],tolower)
    
    # Check for fields absent in the SDRF
    not.present <- (! idf.attrs %in% normalize.cols(colnames(sdrf)))
    
    if (sum(not.present)) {
      perror("IDF error in EAAdditionalAttributes:",paste(idf.attrs[not.present],sep=",")," not found in SDRF")
      q(status=1)
    }
  }
}

# Having derived possible single-cell status from the IDF we can add
# single-cell specific things to the checks.

if( is.singlecell ) {
  
  pinfo("Single cell experiment found")
  
  sc.opt.cols <- c("single cell quality","input molecule","end bias","single cell library method","read1 file","read2 file","index1 file", "index2 file","index3 file")
  
  supported.single.cell.protocols <- c("smart-seq2","smarter","smart-like","10xv2","10xv1","drop-seq","10xv1a")
  sc.droplet.protocols <- c('10xv1', '10xv1a', '10xv1i', '10xv2', 'drop-seq')
  
  expected.cols <- append(expected.cols, c("Material Type","library_construction","single cell isolation"))
  expected.comment.cols <- append(expected.comment.cols, c("LIBRARY_STRAND"))
  opt.cols <- append(opt.cols,sc.opt.cols)
}

# Now do the checks

print.info("Checking presence of columns...")

found <- colsInSDRF(expected.cols, sdrf, exit.on.error = TRUE)
found <- colsInSDRF(expected.characteristic.cols,sdrf,characteristic.cols=TRUE, exit.on.error = TRUE)
found <- colsInSDRF(expected.comment.cols,sdrf,comment.cols=TRUE, exit.on.error = TRUE)
found <- colsInSDRF(expected.factor.cols,sdrf,factor.cols=TRUE, exit.on.error = TRUE)

print.info("Checking the presence of columns... done.")

# Now we've checked comments etc we can forget what sort of field these are and
# regularise the column names

colnames(sdrf) <- normalize.cols(tolower(colnames(sdrf)))

################################################################################
# Further SDRF checks now we know the right fields are there and we can look at
# the content
################################################################################

## User can specify species, in which case we can discard irrelevant rows

sdrf$organism <- gsub(" ","_",tolower(sdrf$organism))

if ( !is.null(opt$species) ) {
  if ( !opt$species %in% sdrf$organism ) {
    perror("SDRF: Species ", opt$species, " not found")
    q(status=1)
  }
  sdrf <- sdrf[sdrf$organism == opt$species, ]
}

print.info("Species: ",paste(unique(sdrf$organism)),"\n")

## SDRF-wide single-cell checks. This can result in filtering out rows, so do it
## early. In the process we also work out what fastq files are required

if ( is.singlecell ) {
  
  ## single cell quality
  
  sc.quality.col <- 'single cell quality'
  
  if ( colsInSDRF(sc.quality.col, sdrf) ){
    
    sdrf <- setSDRFCol(sc.quality.col, sdrf, gsub(" +"," ", tolower(getSDRFCol(sc.quality.col, sdrf))))
    single.cell.quality.counts <- table(getSDRFCol(sc.quality.col, sdrf))
    
    ## Discard cells from analysis that are low quality
    ## OK, OK filtered or not OK
    
    print.info("Discarding ",single.cell.quality.counts["not ok"]," runs/cells")
    sdrf <- sdrf[getSDRFCol(sc.quality.col, sdrf) != 'not ok', ]
  }
  
  # Check the single cell protocol
  
  protocol.corrections <- list(
    'smart-like' = 'smart-seq',
    'Smart-seq2' = 'smart-seq2',
    '10xv2' = '10xV2'
  )
  
  protocols <- getSDRFCol(sc.protocol.col, sdrf)
  for (prot in names(protocol.corrections)){
    protocols[protocols == prot] <- protocol.corrections[[prot]]
  }
  
  sdrf <- setSDRFCol(sc.protocol.col, sdrf, protocols)
  
  # Check that all sc protocols are valid
  
  protocols <- tolower(protocols)
  
  not.valid.sc.protocol <- unique(protocols[! protocols %in% supported.single.cell.protocols])
  
  if ( length(not.valid.sc.protocol) ) {
    perror("SDRF: Unsupported single cell protocol ", not.valid.sc.protocol)
    q(status=1)
  }
  
  # Ignore single-cell identifier for droplet-only experiments
  
  if (all(protocols %in% sc.droplet.protocols) && sc.identifier.col %in% factors) {
    addWarning("You have supplied 'single cell identifier' for an exclusively droplet-based experiment. This column is meaningless in this context and will be ignored")
    factors <- factors[factors != sc.identifier.col]
    sdrf <- sdrf[, colnames(sdrf) != sc.identifier.col]
  }
  
  # Correct layout for droplet libraries
  
  library.layout <- getSDRFCol('library_layout', sdrf)
  library.layout[ library.layout == 'PAIRED' & is.droplet.protocol(protocols) ] <- 'SINGLE'
  sdrf <- setSDRFCol('library_layout', sdrf, library.layout)
  
  ## For every run, derive required file fields
  
  # Rules for droplet protocols
  # 10Xv1: ?
  # 10Xv1a: read 1 = cDNA, read 2 = UMI barcode, index 1 = cell barcode, index 2 = sample barcode (not required)
  # 10Xv1i: read 1 = interleaved cDNA + UMI barcode, read 2 = interleaved cDNA + UMI barcode, index 1 = cell barcode, index 2 = sample barcode (not required)
  # 10Xv2: read 1 = cell + UMI barcodes, read 2 = cDNA, index 1 = sample barcode (not required)
  # Drop-seq: read 1 = cell + UMI barcodes, read 2 = cDNA
  
  sc.required.fastq.fields = list(
    '10xv1' = c('read1 file', 'read2 file'),    
    '10xv1a' = c('read1 file', 'read2 file', 'index1 file'),         
    '10xv1i' = c('read1 file', 'read2 file', 'index1 file'),
    '10xv2' = c('read1 file', 'read2 file'),
    'drop-seq' = c('read1 file', 'read2 file'), 
    "smart-seq2" = 'fastq uri',
    "smarter" = 'fastq uri',
    "smart-like = 'fastq uri"
  )
  
  row.required.fastq.fields <- sc.required.fastq.fields[match(protocols, tolower(names(sc.required.fastq.fields)))] 
  
  sc.optional.fastq.fields = list(
    '10xv1' = c('index1 file', 'index2 file'),    
    '10xv1a' = c('index2 file'),         
    '10xv1i' = c('index2 file'),
    '10xv2' = c('index1 file'),
    'drop-seq' = c(),
    "smart-seq2" = c(),
    "smarter" = c(),
    "smart-like" = c()
  )
  
  # Consider any of the optional file fields that occur in the SDRF
  
  row.optional.fastq.fields <- lapply(sc.optional.fastq.fields[match(protocols, tolower(names(sc.optional.fastq.fields)))], function(x) intersect(x, colnames(sdrf))) 
  
}else{
  
  # For bulk, just check rows for fastq_uri
  
  row.required.fastq.fields <- rep(list('fastq_uri'), nrow(sdrf))
  row.optional.fastq.fields <- rep(list(c()), nrow(sdrf))
}

## Check for run ID. If it's not there as 'run' it needs to be there as
## 'ena_run'

if ( ! colsInSDRF('run', sdrf) ) {
  # ENA_RUN must be present
  if ( ! colsInSDRF('ena run', sdrf) ) {
    perror("SDRF: expected RUN or ENA_RUN - none found")
    q(status=1)
  }else{
    addWarning("SDRF: run column not found, using ena_run")
    sdrf$run <- getSDRFCol('ena_run', sdrf)
    
    ## fix the run names (should not include # )
    sdrf$run <- gsub("#","_",sdrf$run)
  }
}

################################################################################
# Check that:
# 1 - all the necessary file fields exist
# 2 - they have defined values for compulsory field for their technology
# 3 - the indicated files actually exist
#
# SDRF files have a FASTQ_URI column for specifying links to FASTQ files, and
# for droplet techs we also have fields like 'read1 file', 'index1 file' etc,
# which are just file names.
#
# The following assumes:
#
#  - FASTQ files can be found in the specified directories
#  - Single-cell droplet protocols have one run per line with multiple files. We ignore the multiple FASTQ URIs
#  - Bulk and SMART-like protocols have one line per file with a single FASTQ URI in each
################################################################################

all.required.fastq.fields <- unique(unlist(row.required.fastq.fields))
fastq.fields.in.sdrf <- colsInSDRF(all.required.fastq.fields, sdrf)

## Check the actual fields exist

if (any(! fastq.fields.in.sdrf)){
  perror(paste("FASTQ file field (s)", paste(all.required.fastq.fields[! fastq.fields.in.sdrf], collapse=','), 'missing'))
  q(status=1)
}

## Determine required file names on each row using the derived field names

row.files <- lapply(1:nrow(sdrf), function(row.no){
  req.fields <- row.required.fastq.fields[[row.no]]
  structure(basename(as.character(sdrf[row.no, req.fields])), names = req.fields)
})

## Check that the required fields are populated

rows.with.undefined.files <- which(unlist(lapply(row.files, function(x) any(! populated(x)))))

if (length(rows.with.undefined.files) > 0){
  undefined.row.files <- paste(unlist(lapply(rows.with.undefined.files, function(x) paste(paste0('Row ', x, ':'), paste(names(row.files[[x]])[ ! populated(row.files[[x]])], collapse=',')))), collapse="\n")
  
  perror("SDRF: some rows have missing values for required files: \n", undefined.row.files)
  q(status=1)
}

## Add in any optional files with defined values

row.files <- lapply(1:nrow(sdrf), function(row.no){
  opt.fields <- row.optional.fastq.fields[[row.no]]
  if (length(opt.fields) > 0 ){
    opt.files <- basename(sdrf[row.no, opt.fields])
    names(opt.files) <- opt.fields
    c(row.files[[row.no]], opt.files[populated(opt.files)])
  }else{
    row.files[[row.no]]
  }
})

## Provided we're not just checking file validity, check that all specified
## files actually exist

if ( ! opt$check_only ) {
  
  fastq.dir <- file.path(opt$data_dir,"raw_data", opt$raw_dir)
  rows.files.exist <- lapply(row.files, function(x) fastqFileExists(x, fastq.dir, subfolders=split.files.by.subfolders) )
  
  rows.with.missing.files <- which(unlist(lapply(rows.files.exist, function(x) any(! x))))
  
  if (length(rows.with.missing.files) > 0){
    missing.row.files <- unlist(lapply(rows.with.missing.files, function(x) paste(paste0('Row ', x, ':'), paste(names(row.files[[x]])[ ! rows.files.exist[[x]]], collapse=','))))
    
    first_missing <- missing.row.files[1:min(length(missing.row.files),10)]
    
    perror("SDRF: some rows have missing files. Up to first 10 examples: \n", paste(first_missing, collapse = '\n'))
    q(status=1)
  }
}

## Check there are the required number of rows (and therefore files) for
## paired-endedness

# single-end runs
se.runs <- unique(sdrf$run[!grepl("PAIRED", getSDRFCol('library_layout', sdrf),ignore.case=TRUE)])

# paired-end runs
pe.runs <- unique(sdrf$run[grepl("PAIRED", getSDRFCol('library_layout', sdrf),ignore.case=TRUE)])

n.paired.run.files <- table(sdrf$run[sdrf$run %in% pe.runs])

if(any(n.paired.run.files != 2)){
  perror(paste('Paired runs', paste(names(n.paired.run.files[which(n.paired.run.files != 2)]), collapse=', '), 'did not have two run files'))
  q(status=1)
}

## Finally, collapse to files per run

run.fastq.files <- lapply(unique(sdrf$run), function(run){
  
  # If there are multiple rows, then this is paired-end. Sort so that first
  # read file comes first. Otherwise maintain ordering

  fq.files <- unlist(row.files[sdrf$run == run])
  
  if ( length(which(sdrf$run == run)) > 1 ){
    sort(fq.files)  
  }else{
    fq.files
  }
})
names(run.fastq.files) <- unique(sdrf$run)

################################################################################
# We'll be making a config per species, and these sub-experiments will then we
# analysed separately. So checks that with an experimental context (presence of
# technical replication, consistency of spikeins etc) need to be done within
# that species.
################################################################################

sdrf.by.species <- split(sdrf, sdrf$organism)

# Run the checks first

species.properties <- list()

for (species in names(sdrf.by.species)){
  
  species.sdrf <- sdrf.by.species[[species]]
  
  # Some default propertiesa
  
  properties <- list(
    has.spikes = FALSE,
    has.techreps = FALSE
  )
  
  # Filtering could have removed all rows for a species
  
  if (nrow(species.sdrf) == 0){
    perror(paste0('No rows remaining for ', species, ', check filtering'))
    q(status=1)
  }
  
  ## Spikes? Assert that there are no spike-ins unless the field is populated with
  ## non-empty values of a single type.
  
  if ( colsInSDRF('spike_in', species.sdrf) ) {
    print.info("Found 'spike in' column")
    spikein <- unique(getSDRFCol('spike_in', species.sdrf))
    if ( length(spikein) > 1 ) {
      perror("SDRF error: Expected one or no spike ins (found ",length(spikein),").")
      q(status=1)
    }else if (populated(spikein)){
      properties$has.spikes <- TRUE
    }
  }
  
  ## Check for technical replicates . Consider that there are no tech rep groups
  ## if:
  ##   1) all values are empty ('' or NA) 
  ##   or 2) there is a single value
    
  nruns <- length(unique(getSDRFCol('run', species.sdrf)))
  
  if ( colsInSDRF(techrep.col, species.sdrf) ) {
    tr <- getSDRFCol(techrep.col, species.sdrf)
    n.techrep.groups <- length(unique(tr))
    
    is.empty <- tr == "" | is.na(tr) | tr == 'NA' | tr == 'not applicable'
    
    if ( (! all(is.empty)) && any(is.empty) ){
      perror("SDRF: Found ",sum(is.empty)," entries in technical replicate group without values where some values are set")
      q(status=1)
    }else if(n.techrep.groups == 1 ||  n.techrep.groups == nruns){
      
      # If the technica replicate field has been set, but the group numbers don't
      # indicate technical replication (i.e. every run has its own group, or
      # there's only only 1), we would normally say that there is in fact no
      # technical replication. But since droplet protocols have multiple cells per
      # run we'll give these entries the benefit of the doubt.
      
      if (is.singlecell && all(is.droplet.protocol(unique(getSDRFCol('library construction', species.sdrf))))){
        properties$has.techrep <- TRUE
      }
    }else{
      properties$has.techrep <- TRUE
    }
  }
  
  # ENA sample. Check that the sample names don't suggest we should have technical
  # replicates when we don't
  
  if ( colsInSDRF('ena_sample', species.sdrf) ) {
    nsamples <- length(unique(getSDRFCol('ena_sample', species.sdrf)))
    has.techrep.from.samples <- nsamples != nruns
    if ( has.techrep.from.samples != properties$has.techrep  ) {
      addWarning(paste("Technical replicate group from", techrep.col, paste0('(',properties$has.techrep,')'), " inconsistent with ena_sample", paste0('(',has.techrep.from.samples,')')))
    }
  }
  
  if (is.singlecell){
    
    # Need a single protocol
    
    species.protocols <- unique(getSDRFCol(sc.protocol.col, species.sdrf))
    if (length(species.protocols) > 1){
      perror("multiple library construction values:",paste(species.protocols,sep=","))
      q(status=1)
    }
  }
  
  species.properties[[species]] <- properties 
}

# With all checks done, we can stop if no further output is required

pinfo("SDRF/IDF looks OK!")    

if ( opt$check_only ) {
  printAllWarnings()
  pinfo("<<< All done: SDRF validation complete, exiting before config creation")
  q(status=0)
}

# Now generate config and metadata

configs <- lapply(names(sdrf.by.species), function(species){
  
  species.sdrf <- sdrf.by.species[[species]]
  properties <- species.properties[[species]]
  
  # layout is the SDRF with the duplicated lanes for paired end removed
  species.layout <- species.sdrf[!duplicated(species.sdrf$run),,drop=FALSE]
  rownames(species.layout) <- species.layout$run
  
  ## Anything other than ERCC will be commented
  
  spikes.conf="spikein_fasta="
  
  if (properties$has.spikes){
    spikein <- tolower(unique(getSDRFCol('spike_in', sdrf)))
    if ( grepl("ercc.*",spikein) ) {
      spikes.conf="spikein_fasta=ERCC"
    }else{
      spikes.conf=paste0("#spikein_fasta=",spikein)
    }
  }
  
  ## Set up for technical replication (or not)
  
  techreps.conf=#technical_replicates="
    
    if(properties$has.techrep) {
      
      # Subset the layout to get samples and replicate groups
      techreps.runs <- getSDRFCol(c('run', techrep.col), species.layout, order.by = techrep.col)
      
      # Group runs/samples by techrep group
      techreps.by.group <- aggregate( techreps.runs$run, by=list(techrep.group=techreps.runs[,2]), FUN=paste, collapse="," )
      
      techrep.run.groups <- paste(unlist(techreps.by.group$x),collapse=";",sep="")
      techrep.group.labels <- paste(techreps.by.group$techrep.group,collapse=";",sep="")
      
      techreps.conf = paste(paste0("technical_replicates=", techrep.run.groups), paste0("technical_replicates_labels=",techrep.group.labels), sep = "\n")  
    }
  
  # SC prototol
  
  sc.prot.conf = c()
  sc.clusters.conf = c()
  
  if (is.singlecell){
    sc.prot.conf = paste0("sc_protocol=", getSDRFCol(sc.protocol.col, species.sdrf)[1])
    
    ## Decide what range of K values to try. Use a window around the provided
    ## central k
    
    # Guess at a central K when not provided
    
    if ( opt$nc < 2 ) {
      opt$nc <- round(log2(nrow(species.layout)))
    }
    
    num.min.c <- max(round(opt$nc - opt$nc_window/2,0),2)
    num.max.c <- num.min.c + opt$nc_window
    
    sc.clusters.conf = c(
      paste0("min_clusters=",num.min.c),
      paste0("max_clusters=",num.max.c)
    )
  }
  
  # Run-wise info
  info.conf <- c()
  
  # Get the combined .info file content of each run
  
  pinfo("Deriving run information from .info files...")
  run.info <- unlist(lapply(species.layout$run, function(x) getRunInfo(x, species.layout) ))
  pinfo("Run info retrieval done")  

  if (! is.null(run.info)){
    info.conf <- run.info
  }
  
  # Generate config file content
  
  config = c(
    paste("# iRAPs configuration file for", opt$name),
    paste("# Generated", date(), "from", opt$sdrf),
    paste0("name=", opt$name),
    paste0("species=", tolower(species)),
    paste0("data_dir=", opt$data_dir),
    paste0("raw_folder=", opt$raw_dir),
    paste0("sop=", opt$sop),
    paste("include", opt$species_conf),
    paste0("se=",paste(gsub("^","",se.runs),collapse=" ")),
    paste0("pe=",paste(gsub("^","",pe.runs),collapse=" ")),
    spikes.conf,
    techreps.conf,
    sc.prot.conf,
    sc.clusters.conf,
    info.conf
  )
  
  # Generate metadata file content to save
  
  metadata <- NULL
  
  sdfcols2save2tsv <- unique(c(
    factors,
    idf.factors,
    idf.attrs,
    techrep.col
  ))
  
  if (length(sdfcols2save2tsv) > 0){
    metadata <- getSDRFCol(sdfcols2save2tsv, species.layout, drop = FALSE)
    metadata <- cbind(run=rownames(metadata),metadata)
  }
  
  list(config=config, metadata=metadata)
})

names(configs) <- names(sdrf.by.species)


if ( length(configs)==0 ) {
  perror("Unable to create configuration file, see above errors")
  q(status=1)
}

## Write final outputs

cat("\n")
pinfo("### SDRF summary info\n")
cat("Columns: ",ncol(sdrf),"\n")
cat("Entries: ",nrow(sdrf),"\n")
pinfo("Columns found in SDRF:")
cat(paste(colnames(sdrf),collapse=","),"\n")

## print the values
pinfo("Most frequent values per column...")
for (col in tolower(c(expected.cols,expected.comment.cols,expected.factor.cols,expected.characteristic.cols)) ) {
  # ignore spaces
  col <- normalize.cols(col,FALSE)
  tt <- table(sdrf[,col])
  if (length(tt)==nrow(sdrf) ) {
    pinfo(col,": single value per row")
  } else {
    pinfo(col,": ",length(tt)," unique values")
  }
}

cat("\n")
pinfo("### Warnings\n")
printAllWarnings()

cat("\n")
pinfo("### Outputs\n")

for (species in names(configs)){
  
  # If we've had multiple species then apply an appropriate suffix
  
  species_suffix=''
  if (length(configs) > 1){
    species_suffix <- paste0("_", species)
  }
  
  config <- configs[[species]]$config
  metadata <- configs[[species]]$metadata
  
  conf.file <- paste0(opt$out_conf, species_suffix, ".conf")
  meta.file <- paste0(opt$out_conf, species_suffix,".metadata.tsv")
  
  # If there is metadata then point to it from the config file
  
  if ( ! is.null(metadata)){
    config <- c(config, paste0("extra_metadata=", basename(meta.file)))
    write.tsv(metadata, file=meta.file, header=TRUE)
    pinfo("Created ", meta.file)
  }
  
  writeLines(config, con = conf.file)
  pinfo("Created ", conf.file)
}

cat("\n")
pinfo("<<< All done: SDRF validation complete")
q(status=0)
